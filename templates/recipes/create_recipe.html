<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Create Recipe</title>
  <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body class="recipes-page">

  <a href="/recipes/" class="back-link">← All Recipes</a>
  <h1>Create New Recipe</h1>

  <!-- Recipe Info -->
  <section id="recipe-info-section">
    <label for="recipe-name">Recipe Name:</label>
    <input type="text" id="recipe-name" name="recipe-name" placeholder="Enter recipe name">
    <div class="error-create-recipe" id="errorName"></div>

    <label for="portion-size">Portion Size:</label>
    <input type="text" id="portion-size" name="portion-size" placeholder="e.g., 2 portion or 3 people or 1.5 kg, etc.">
    <div class="error-create-recipe" id="errorPS"></div>

    <label for="description">Description:</label>
    <textarea id="description" name="description" rows="3" placeholder="Enter description"></textarea>
    <div class="error-create-recipe" id="errorDesc"></div>

    <label for="privacy">Private Recipe:</label>
    <input type="checkbox" id="privacy" name="privacy" checked>
  </section>

  <!-- Placeholder for Recipe Image -->
  <section id="recipe-image-section">
    <p>Recipe image placeholder (to be added later)</p>
    <div class="image-placeholder"></div>
  </section>

  <!-- Ingredients Table with 10 rows -->
  <h2>Ingredients</h2>
  <table id="ingredients-table">
    <thead>
      <tr>
        <th>Ingredient</th>
        <th>Quantity</th>
        <th>Unit</th>
        <th>Base Quantity</th>
        <th>Base Unit</th>
        <th>Base Price</th>
      </tr>
    </thead>
    <tbody>
      <!-- 10 empty rows -->
      {% for i in range(10) %}
      <tr>
        <td style="position: relative;">
            <input type="text" 
                    name="ingredient_name_{{i}}" 
                    class="ingredient-input" 
                    placeholder="Ingredient" 
                    autocomplete="off">
            <div class="suggestions" id="suggestions_{{i}}"></div>
        </td>
        <td><input type="number" step="any" name="quantity_{{i}}" placeholder="Qty"></td>
        <td>
          <select name="unit_{{i}}" class="unit-select">
            <option value="">-- Select unit --</option>
          </select>
        </td>
        <td><input type="number" step="any" name="base_quantity_{{i}}" placeholder="Base Qty"></td>
        <td><input type="text" name="base_unit_{{i}}" placeholder="Base Unit"></td>
        <td><input type="number" step="any" name="base_price_{{i}}" placeholder="Base Price"></td>
      </tr>
      {% endfor %}
    </tbody>
  </table>

  <!-- Steps with 10 rows -->
  <h2>Steps</h2>
  <table id="steps-table">
    <thead>
      <tr>
        <th>Step Number</th>
        <th>Step Text</th>
      </tr>
    </thead>
    <tbody>
      {% for i in range(10) %}
      <tr>
        <td>{{ i+1 }}</td>
        <td><input type="text" name="step_text_{{i}}" placeholder="Step description"></td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
  <div id="error" class="error-message"></div>
  <button type="submit" id="submit-recipe-btn">Save Recipe</button>

  <script>
    function validateRecipeForm() {
        const name = document.getElementById("recipe-name").value.trim();
        const portionSize = document.getElementById("portion-size").value.trim();
        const description = document.getElementById("description").value.trim();
        const privacy = document.getElementById("privacy").checked ? "private" : "public";

        const errorName = document.getElementById("errorName");
        const errorPS = document.getElementById("errorPS");
        const errorDesc = document.getElementById("errorDesc");

        // Clear old errors
        errorName.textContent = "";
        errorPS.textContent = "";
        errorDesc.textContent = "";
        document.getElementById("error").textContent = "";

        let hasError = false;

        // --- Name validation ---
        if (!name) {
            errorName.textContent = "Recipe name is required.";
            hasError = true;
        } else if (name.length > 50) {
            errorName.textContent = "Recipe name must be less than 50 characters.";
            hasError = true;
        }

        // --- Portion size validation ---
        if (!portionSize) {
            errorPS.textContent = "Portion size is required.";
            hasError = true;
        } else if (portionSize.length > 20) {
            errorPS.textContent = "Portion size must be less than 20 characters.";
            hasError = true;
        }

        // --- Description validation ---
        if (description.length > 500) {
            errorDesc.textContent = "Description must be ≤ 500 characters.";
            hasError = true;
        }

        // --- Privacy validation (shouldn’t fail normally) ---
        if (!["public", "private"].includes(privacy)) {
            document.getElementById("error").textContent = "Privacy must be public or private.";
            hasError = true;
        }

        if (hasError) return false;

        return { name, portion_size: portionSize, description, privacy };
        }
    
    function populateUnits(row, ingredientId) {
      const unitSelect = row.querySelector(".unit-select");
      // Clear previous options
      unitSelect.innerHTML = '<option value="">-- Select unit --</option>';
      //console.log("ingredientId from func populateUnits: ", ingredientId)
      if (!ingredientId) return; // No ingredient, leave empty

      fetch(`/recipes/api/ingredient-units?ingredient=${encodeURIComponent(ingredientId)}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`
        }
      })
        .then(res => res.json())
        .then(data => {
          data.forEach(unit => {
            const option = document.createElement("option");
            option.value = unit.unit_id;
            option.textContent = unit.unit_name;
            unitSelect.appendChild(option);
          });
        })
        .catch(err => console.error("Failed to fetch units:", err));
    }

    function validateIngredientsForm() {
      const rows = document.querySelectorAll("#ingredients-table tbody tr");
      let filledRowsCount = 0;
      let errorMessage = "";
      const ingredientsData = [];

      rows.forEach((row, index) => {
        const nameInput = row.querySelector(`input[name^="ingredient_name_"]`);
        const quantityInput = row.querySelector(`input[name^="quantity_"]`);
        const unitSelect = row.querySelector(`select[name^="unit_"]`);
        const baseQtyInput = row.querySelector(`input[name^="base_quantity_"]`);
        const baseUnitInput = row.querySelector(`input[name^="base_unit_"]`);
        const basePriceInput = row.querySelector(`input[name^="base_price_"]`);

        const values = [
          nameInput.value.trim(),
          quantityInput.value.trim(),
          unitSelect.value.trim(),
          baseQtyInput.value.trim(),
          baseUnitInput.value.trim(),
          basePriceInput.value.trim()
        ];

        const isAnyFieldFilled = values.some(v => v !== "");
        const isAllFieldsFilled = values.every(v => v !== "");

        if (isAnyFieldFilled && !isAllFieldsFilled) {
          errorMessage = `Row ${index + 1}: All fields must be filled if any field is entered.`;
        }

        if (isAllFieldsFilled) {
          filledRowsCount++;

          // Collect ingredient details into an object
          ingredientsData.push({
            name: nameInput.value.trim(),
            quantity: parseFloat(quantityInput.value),
            unit: unitSelect.value,
            base_quantity: parseFloat(baseQtyInput.value),
            base_unit: baseUnitInput.value,
            base_price: parseFloat(basePriceInput.value)
          });
        }
      });

      if (!errorMessage && filledRowsCount < 2) {
        errorMessage = "At least 2 rows of ingredients must be fully filled.";
      }

      if (errorMessage) {
        document.getElementById("error").textContent = errorMessage;
        return false;
      }

      // Clear previous error
      document.getElementById("error").textContent = "";

      return ingredientsData; // return the list of ingredient objects
    }

    document.querySelectorAll(".ingredient-input").forEach((input, index) => {
      const suggestionBox = document.getElementById(`suggestions_${index}`);
      let fetchedIngredients = [];   // store suggestions from API
      let activeIndex = -1;          // for keyboard navigation
      let ingredientData = [];       // store full data with price/base_unit

      // --- Fetch suggestions as user types ---
      input.addEventListener("input", async function () {
        const query = this.value.trim().toLowerCase();
        activeIndex = -1; // reset navigation
        if (query.length < 1) {
          suggestionBox.style.display = "none";
          return;
        }

        try {
          const res = await fetch(`/recipes/api/ingredients/search?q=${encodeURIComponent(query)}`, {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${token}`
            }
          });

          if (!res.ok) throw new Error("Failed to fetch ingredients");

          const data = await res.json();
          ingredientData = data; // store full data
          fetchedIngredients = data.map(item => item.name.toLowerCase());

          suggestionBox.innerHTML = "";
          if (data.length === 0) {
            suggestionBox.style.display = "none";
            return;
          }

          data.forEach(item => {
            const div = document.createElement("div");
            div.textContent = item.name;
            div.classList.add("suggestion-item");

            div.addEventListener("click", () => {
              selectIngredient(item);
            });

            suggestionBox.appendChild(div);
          });

          suggestionBox.style.display = "block";
        } catch (err) {
          console.error("Error fetching ingredients:", err);
        }
      });

      // --- Keyboard navigation ---
      input.addEventListener("keydown", function (e) {
        const items = suggestionBox.querySelectorAll(".suggestion-item");
        if (items.length === 0) return;

        if (e.key === "ArrowDown") {
          e.preventDefault();
          activeIndex = (activeIndex + 1) % items.length;
          highlightItem(items, activeIndex);
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          activeIndex = (activeIndex - 1 + items.length) % items.length;
          highlightItem(items, activeIndex);
        } else if (e.key === "Enter" || e.key === "Tab") {
          if (activeIndex >= 0 && activeIndex < items.length) {
            const selectedItem = ingredientData.find(d => d.name === items[activeIndex].textContent);
            selectIngredient(selectedItem);
          }
          suggestionBox.style.display = "none";
          // allow Tab to move focus naturally
        }
      });

      // --- Blur handling: clear invalid values ---
      input.addEventListener("blur", function () {
        setTimeout(() => {
          const items = suggestionBox.querySelectorAll(".suggestion-item");

          if (activeIndex >= 0 && activeIndex < items.length) {
            // Keep highlighted value
            const selectedItem = ingredientData.find(d => d.name === items[activeIndex].textContent);
            if (selectedItem) selectIngredient(selectedItem);
          } else if (!fetchedIngredients.includes(this.value.trim().toLowerCase())) {
            // Clear invalid input
            this.value = "";
            const row = input.closest("tr");
            row.querySelector(`input[name="base_quantity_${index}"]`).value = "";
            row.querySelector(`input[name="base_unit_${index}"]`).value = "";
            row.querySelector(`input[name="base_price_${index}"]`).value = "";
          }

          suggestionBox.style.display = "none";
          activeIndex = -1;
        }, 150);
      });

      // --- Helper: highlight active item and scroll ---
      function highlightItem(items, index) {
        items.forEach((item, i) => {
          item.style.background = (i === index) ? "#ddd" : "";
        });

        if (index >= 0) {
          items[index].scrollIntoView({ behavior: "smooth", block: "nearest" });
        }
      }

      // --- Helper: select ingredient and populate base fields ---
      function selectIngredient(item) {
        //console.log(item)
        input.value = item.name;
        const row = input.closest("tr");

        // Store ingredient ID in row for later use
        row.dataset.ingredientId = item.ingredient_id
        //console.log("row is : ",row)
        //console.log("row's ingredient id is : ",item.ingredient_id)
        row.querySelector(`input[name="base_quantity_${index}"]`).value = 1;
        row.querySelector(`input[name="base_unit_${index}"]`).value = item.base_unit || "";
        row.querySelector(`input[name="base_price_${index}"]`).value = item.price || "";

        // Populate units dropdown
        populateUnits(row, item.ingredient_id);
      }
    });

    document.getElementById("submit-recipe-btn").addEventListener("click", async () => {
      const completeRecipe = []
      const recipeData = validateRecipeForm();      
      if (!recipeData) return; // errors displayed, stop submission
      const ingredientsData = validateIngredientsForm();
      if (!ingredientsData) return; // validation failed

      // Combine into a single object
      completeRecipe.push({
        recipe: recipeData,
        ingredients: ingredientsData
      });

      console.log("Validated recipe data:", recipeData);
      console.log("Validated ingredients data:", ingredientsData);
      console.log("complete recipe data: ", completeRecipe)
      
      // Send ingredient name to backend API...
    });

    const token = localStorage.getItem("access_token");






  </script>
</body>
</html>
