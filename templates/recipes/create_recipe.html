<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Create Recipe</title>
  <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body class="recipes-page">

  <a href="/recipes/" class="back-link">← All Recipes</a>
  <h1>Create New Recipe</h1>

  <!-- Recipe Info -->
  <section id="recipe-info-section">
    <label for="recipe-name">Recipe Name:</label>
    <input type="text" id="recipe-name" name="recipe-name" placeholder="Enter recipe name">
    <div class="error-create-recipe" id="errorName"></div>

    <label for="portion-size">Portion Size:</label>
    <input type="text" id="portion-size" name="portion-size" placeholder="e.g., 2 portion or 3 people or 1.5 kg, etc.">
    <div class="error-create-recipe" id="errorPS"></div>

    <label for="description">Description:</label>
    <textarea id="description" name="description" rows="3" placeholder="Enter description"></textarea>
    <div class="error-create-recipe" id="errorDesc"></div>

    <label for="privacy">Private Recipe:</label>
    <input type="checkbox" id="privacy" name="privacy" checked>
  </section>

  <!-- Placeholder for Recipe Image -->
  <section id="recipe-image-section">
    <p>Recipe image placeholder (to be added later)</p>
    <div class="image-placeholder"></div>
  </section>

  <!-- Ingredients Table with 10 rows -->
  <h2>Ingredients</h2>
  <table id="ingredients-table">
    <thead>
      <tr>
        <th>Ingredient</th>
        <th>Quantity</th>
        <th>Unit</th>
        <th>Base Quantity</th>
        <th>Base Unit</th>
        <th>Base Price</th>
      </tr>
    </thead>
    <tbody id="ingredients-tbody">
      <tr>
        <td style="position: relative;">
          <input type="text" name="ingredient_name_0" class="ingredient-input" placeholder="Ingredient" autocomplete="off">
          <div class="suggestions" id="suggestions_0"></div>
        </td>
        <td><input type="number" step="any" name="quantity_0" placeholder="Qty" min="0.01" class="validated-number"></td>
        <td>
          <select name="unit_0" class="unit-select">
            <option value="">-- Select unit --</option>
          </select>
        </td>
        <td><input type="number" step="any" name="base_quantity_0" placeholder="Base Qty" min="0.01" class="validated-number"></td>
        <td><input type="text" name="base_unit_0" placeholder="Base Unit"></td>
        <td><input type="number" step="any" name="base_price_0" placeholder="Base Price" min="0.01" class="validated-number"></td>
      </tr>

      <tr>
        <td style="position: relative;">
          <input type="text" name="ingredient_name_1" class="ingredient-input" placeholder="Ingredient" autocomplete="off">
          <div class="suggestions" id="suggestions_1"></div>
        </td>
        <td><input type="number" step="any" name="quantity_1" placeholder="Qty"></td>
        <td>
          <select name="unit_1" class="unit-select">
            <option value="">-- Select unit --</option>
          </select>
        </td>
        <td><input type="number" step="any" name="base_quantity_1" placeholder="Base Qty"></td>
        <td><input type="text" name="base_unit_1" placeholder="Base Unit"></td>
        <td><input type="number" step="any" name="base_price_1" placeholder="Base Price"></td>
      </tr>
    </tbody>


  </table>

  <!-- Steps with 10 rows -->
  <h2>Steps</h2>
  <table id="steps-table">
    <thead>
      <tr>
        <th>Step Number</th>
        <th>Step Text</th>
      </tr>
    </thead>
    <tbody id="steps-tbody">
      <!-- Initially only 1 row -->
      <tr>
        <td>1</td>
        <td>
          <input type="text" name="step_text_0" class="step-input" placeholder="Step description">
        </td>
      </tr>
    </tbody>
  </table>
  <div id="error" class="error-message"></div>
  <button type="submit" id="submit-recipe-btn">Save Recipe</button>

  <script>
    const token = localStorage.getItem("access_token");

    function validateRecipeForm() {
        const name = document.getElementById("recipe-name").value.trim();
        const portionSize = document.getElementById("portion-size").value.trim();
        const description = document.getElementById("description").value.trim();
        const privacy = document.getElementById("privacy").checked ? "private" : "public";

        const errorName = document.getElementById("errorName");
        const errorPS = document.getElementById("errorPS");
        const errorDesc = document.getElementById("errorDesc");

        // Clear old errors
        errorName.textContent = "";
        errorPS.textContent = "";
        errorDesc.textContent = "";
        document.getElementById("error").textContent = "";

        let hasError = false;

        // --- Name validation ---
        if (!name) {
            errorName.textContent = "Recipe name is required.";
            hasError = true;
        } else if (name.length > 50) {
            errorName.textContent = "Recipe name must be less than 50 characters.";
            hasError = true;
        }

        // --- Portion size validation ---
        if (!portionSize) {
            errorPS.textContent = "Portion size is required.";
            hasError = true;
        } else if (portionSize.length > 20) {
            errorPS.textContent = "Portion size must be less than 20 characters.";
            hasError = true;
        }

        // --- Description validation ---
        if (description.length > 500) {
            errorDesc.textContent = "Description must be ≤ 500 characters.";
            hasError = true;
        }

        // --- Privacy validation (shouldn’t fail normally) ---
        if (!["public", "private"].includes(privacy)) {
            document.getElementById("error").textContent = "Privacy must be public or private.";
            hasError = true;
        }

        if (hasError) return false;

        return { name, portion_size: portionSize, description, privacy };
        }
    
    function populateUnits(row, ingredientId) {
      const unitSelect = row.querySelector(".unit-select");
      // Clear previous options
      unitSelect.innerHTML = '<option value="">-- Select unit --</option>';
      //console.log("ingredientId from func populateUnits: ", ingredientId)
      if (!ingredientId) return; // No ingredient, leave empty

      fetch(`/recipes/api/ingredient-units?ingredient=${encodeURIComponent(ingredientId)}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`
        }
      })
        .then(res => res.json())
        .then(data => {
          data.forEach(unit => {
            const option = document.createElement("option");
            option.value = unit.unit_id;
            option.textContent = unit.unit_name;
            unitSelect.appendChild(option);
          });
        })
        .catch(err => console.error("Failed to fetch units.", err));
    }

    function validateIngredientsForm() {
      const rows = document.querySelectorAll("#ingredients-table tbody tr");
      let filledRowsCount = 0;
      let errorMessage = "";
      const ingredientsData = [];

      rows.forEach((row, index) => {
        const nameInput = row.querySelector(`input[name^="ingredient_name_"]`);
        const quantityInput = row.querySelector(`input[name^="quantity_"]`);
        const unitSelect = row.querySelector(`select[name^="unit_"]`);
        const baseQtyInput = row.querySelector(`input[name^="base_quantity_"]`);
        const baseUnitInput = row.querySelector(`input[name^="base_unit_"]`);
        const basePriceInput = row.querySelector(`input[name^="base_price_"]`);

        const values = [
          nameInput.value.trim(),
          quantityInput.value.trim(),
          unitSelect.value.trim(),
          baseQtyInput.value.trim(),
          baseUnitInput.value.trim(),
          basePriceInput.value.trim()
        ];

        const isAnyFieldFilled = values.some(v => v !== "");
        const isAllFieldsFilled = values.every(v => v !== "");

        if (isAnyFieldFilled && !isAllFieldsFilled) {
          errorMessage = `Row ${index + 1}: All fields must be filled if any field is entered.`;
        }

        if (isAllFieldsFilled) {
          filledRowsCount++;

          // Collect ingredient details into an object
          ingredientsData.push({
            name: nameInput.value.trim(),
            quantity: parseFloat(quantityInput.value),
            unit: unitSelect.value,
            base_quantity: parseFloat(baseQtyInput.value),
            base_unit: baseUnitInput.value,
            base_price: parseFloat(basePriceInput.value)
          });
        }
      });

      if (!errorMessage && filledRowsCount < 2) {
        errorMessage = "At least 2 rows of ingredients must be fully filled.";
      }

      if (errorMessage) {
        document.getElementById("error").textContent = errorMessage;
        return false;
      }

      // Clear previous error
      document.getElementById("error").textContent = "";

      return ingredientsData; // return the list of ingredient objects
    }

    function initializeIngredientInput(row, index) {
      const input = row.querySelector(".ingredient-input");
      const suggestionBox = row.querySelector(`#suggestions_${index}`);
      let fetchedIngredients = [];   // store suggestions
      let ingredientData = [];       // full data (id, base_unit, price)
      let activeIndex = -1;

      // --- Fetch suggestions ---
      input.addEventListener("input", async function () {
        const query = this.value.trim().toLowerCase();
        activeIndex = -1;
        if (query.length < 1) {
          suggestionBox.style.display = "none";
          return;
        }

        try {
          const res = await fetch(`/recipes/api/ingredients/search?q=${encodeURIComponent(query)}`, {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${token}`
            }
          });

          if (!res.ok) throw new Error("Failed to fetch ingredients");

          const data = await res.json();
          ingredientData = data;
          fetchedIngredients = data.map(item => item.name.toLowerCase());

          suggestionBox.innerHTML = "";
          if (data.length === 0) {
            suggestionBox.style.display = "none";
            return;
          }

          data.forEach(item => {
            const div = document.createElement("div");
            div.textContent = item.name;
            div.classList.add("suggestion-item");
            div.addEventListener("click", () => selectIngredient(item));
            suggestionBox.appendChild(div);
          });

          suggestionBox.style.display = "block";
        } catch (err) {
          console.error("Error fetching ingredients:", err);
        }
      });

      // --- Keyboard navigation ---
      input.addEventListener("keydown", function (e) {
        const items = suggestionBox.querySelectorAll(".suggestion-item");
        if (items.length === 0) return;

        if (e.key === "ArrowDown") {
          e.preventDefault();
          activeIndex = (activeIndex + 1) % items.length;
          highlightItem(items, activeIndex);
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          activeIndex = (activeIndex - 1 + items.length) % items.length;
          highlightItem(items, activeIndex);
        } else if (e.key === "Enter" || e.key === "Tab") {
          if (activeIndex >= 0 && activeIndex < items.length) {
            selectIngredient(ingredientData.find(d => d.name === items[activeIndex].textContent));
          }
          suggestionBox.style.display = "none";
        }
      });

      // --- Blur handling ---
      input.addEventListener("blur", function () {
        setTimeout(() => {
          const items = suggestionBox.querySelectorAll(".suggestion-item");
          if (activeIndex >= 0 && activeIndex < items.length) {
            selectIngredient(ingredientData.find(d => d.name === items[activeIndex].textContent));
          } else if (!fetchedIngredients.includes(this.value.trim().toLowerCase())) {
            this.value = "";
            const rowIndex = row.rowIndex - 1; // adjust for table header
            row.querySelector(`input[name="base_quantity_${index}"]`).value = "";
            row.querySelector(`input[name="base_unit_${index}"]`).value = "";
            row.querySelector(`input[name="base_price_${index}"]`).value = "";
            row.querySelector(`select[name="unit_${index}"]`).value = "";
          }
          suggestionBox.style.display = "none";
          activeIndex = -1;
        }, 150);
      });

      // --- Helper: highlight suggestion item ---
      function highlightItem(items, idx) {
        items.forEach((item, i) => item.style.background = i === idx ? "#ddd" : "");
        if (idx >= 0) items[idx].scrollIntoView({ behavior: "smooth", block: "nearest" });
      }

      // --- Helper: select ingredient and populate base fields ---
      function selectIngredient(item) {
        if (!item) return;
        input.value = item.name;

        const rowElem = input.closest("tr");
        rowElem.dataset.ingredientId = item.ingredient_id; // store ingredient ID

        // Populate base fields
        rowElem.querySelector(`input[name="base_quantity_${index}"]`).value = 1;
        rowElem.querySelector(`input[name="base_unit_${index}"]`).value = item.base_unit || "";
        rowElem.querySelector(`input[name="base_price_${index}"]`).value = item.price || "";

        // ✅ Use your central populateUnits function
        populateUnits(rowElem, item.ingredient_id);
      }

    }

    function attachNumberValidation(input) {
      // Prevent typing e, E, +, -
      input.addEventListener("keydown", (e) => {
        if (["e", "E", "+", "-"].includes(e.key)) {
          e.preventDefault();
        }
      });

      // Force positive float with max 2 decimals
      input.addEventListener("input", () => {
        let value = input.value;

        // Block zero or negative numbers
        if (value && parseFloat(value) <= 0) {
          input.value = "";
          return;
        }

        // Limit decimals to 2
        if (value.includes(".")) {
          const [int, dec] = value.split(".");
          if (dec.length > 2) {
            input.value = int + "." + dec.slice(0, 2);
          }
        }
      });
    }

        // --- Function to get all steps for submission ---
    function validateStepsForm() {
      const stepsTbody = document.getElementById("steps-tbody");
      const rows = Array.from(stepsTbody.querySelectorAll("tr"));
      const steps = [];
      let error = "";

      rows.forEach((row, i) => {
        const input = row.querySelector(".step-input");
        const value = input.value.trim().replace(/\s{2,}/g, " ");
        console.log("from validateStepForm func value of step text:", value)
        if (value !== "") steps.push(value);
      });

      //if (steps.length === 0) {
      //  error = "Please enter at least 1 step.";
      //}

      if (error) {
        document.getElementById("error").textContent = error;
        return false;
      }

      document.getElementById("error").textContent = "";
      console.log("from validateStepForm func value of steps object", steps)
      return steps;
    }

    document.addEventListener("DOMContentLoaded", function () {
      const tbody = document.getElementById("ingredients-tbody");

      // Attach validation to all initial numeric inputs
      tbody.querySelectorAll("input[name^='quantity_'], input[name^='base_quantity_'], input[name^='base_price_']").forEach(input => {
        attachNumberValidation(input);
      });

      // Attach input listeners to a row
      function attachRowListeners(row) {
        row.querySelectorAll("input, select").forEach(input => {
          input.addEventListener("input", handleRowChange);
        });
      }

      // Handle input changes
      function handleRowChange() {
        const rows = Array.from(tbody.querySelectorAll("tr"));
        const lastRow = rows[rows.length - 1];

        // Check if last row is fully filled
        const values = Array.from(lastRow.querySelectorAll("input, select")).map(i => i.value.trim());
        if (values.every(v => v !== "")) {
          // Create a new empty row dynamically
          const index = rows.length;
          const newRow = document.createElement("tr");
          newRow.innerHTML = `
            <td style="position: relative;">
              <input type="text" name="ingredient_name_${index}" class="ingredient-input" placeholder="Ingredient" autocomplete="off">
              <div class="suggestions" id="suggestions_${index}"></div>
            </td>
            <td><input type="number" step="any" name="quantity_${index}" placeholder="Qty"></td>
            <td>
              <select name="unit_${index}" class="unit-select">
                <option value="">-- Select unit --</option>
              </select>
            </td>
            <td><input type="number" step="any" name="base_quantity_${index}" placeholder="Base Qty"></td>
            <td><input type="text" name="base_unit_${index}" placeholder="Base Unit"></td>
            <td><input type="number" step="any" name="base_price_${index}" placeholder="Base Price"></td>
          `;
          tbody.appendChild(newRow);
          
          // Attach number validation to new numeric inputs
          newRow.querySelectorAll("input[name^='quantity_'], input[name^='base_quantity_'], input[name^='base_price_']").forEach(input => {
            attachNumberValidation(input);
          });

          // Attach other listeners and autocomplete
          attachRowListeners(newRow);
          initializeIngredientInput(newRow, index);
        }
      }

      const stepsTbody = document.getElementById("steps-tbody");

      // Attach listeners to initial rows
      tbody.querySelectorAll("tr").forEach((row, index) => {
        attachRowListeners(row);
        initializeIngredientInput(row, index);
      });     

      // Attach listeners to initial rows of steps
      function attachStepListener(row, index) {
        const input = row.querySelector(".step-input");

        // --- Clean spaces on blur ---
        input.addEventListener("blur", () => {
          input.value = input.value.trim().replace(/\s{2,}/g, " ");
        });

        // --- Add new row dynamically ---
        input.addEventListener("input", () => {
          const rows = Array.from(stepsTbody.querySelectorAll("tr"));
          const lastRow = rows[rows.length - 1];
          const lastInput = lastRow.querySelector(".step-input");

          if (lastInput.value.trim() !== "") {
            const newIndex = rows.length;
            const newRow = document.createElement("tr");
            newRow.innerHTML = `
              <td>${newIndex + 1}</td>
              <td><input type="text" name="step_text_${newIndex}" class="step-input" placeholder="Step description"></td>
            `;
            stepsTbody.appendChild(newRow);

            // Attach listener recursively
            attachStepListener(newRow, newIndex);
          }
        });
      }

      // --- Initialize first step row ---
      attachStepListener(stepsTbody.querySelector("tr"), 0);

    });

    document.querySelectorAll(".ingredient-input").forEach((input, index) => {
      const suggestionBox = document.getElementById(`suggestions_${index}`);
      let fetchedIngredients = [];   // store suggestions from API
      let activeIndex = -1;          // for keyboard navigation
      let ingredientData = [];       // store full data with price/base_unit

      // --- Fetch suggestions as user types ---
      input.addEventListener("input", async function () {
        const query = this.value.trim().toLowerCase();
        activeIndex = -1; // reset navigation
        if (query.length < 1) {
          suggestionBox.style.display = "none";
          return;
        }

        try {
          const res = await fetch(`/recipes/api/ingredients/search?q=${encodeURIComponent(query)}`, {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${token}`
            }
          });

          if (!res.ok) throw new Error("Failed to fetch ingredients");

          const data = await res.json();
          ingredientData = data; // store full data
          fetchedIngredients = data.map(item => item.name.toLowerCase());

          suggestionBox.innerHTML = "";
          if (data.length === 0) {
            suggestionBox.style.display = "none";
            return;
          }

          data.forEach(item => {
            const div = document.createElement("div");
            div.textContent = item.name;
            div.classList.add("suggestion-item");

            div.addEventListener("click", () => {
              selectIngredient(item);
            });

            suggestionBox.appendChild(div);
          });

          suggestionBox.style.display = "block";
        } catch (err) {
          console.error("Error fetching ingredients:", err);
        }
      });

      // --- Keyboard navigation ---
      
      // --- Blur handling: clear invalid values ---
     
      // --- Helper: highlight active item and scroll ---
      
      // --- Helper: select ingredient and populate base fields ---
      
    });

    document.getElementById("submit-recipe-btn").addEventListener("click", async () => {
      const completeRecipe = []
      const recipeData = validateRecipeForm();      
      if (!recipeData) return; // errors displayed, stop submission
      const ingredientsData = validateIngredientsForm();
      if (!ingredientsData) return; // validation failed
      const stepsData = validateStepsForm();
      if (!stepsData) return; // validation failed

      // Combine into a single object
      completeRecipe.push({
        recipe: recipeData,
        ingredients: ingredientsData,
        steps: stepsData
      });

      console.log("Validated recipe data:", recipeData);
      console.log("Validated ingredients data:", ingredientsData);
      console.log("validated Steps data:",stepsData )
      console.log("complete recipe data: ", completeRecipe)
      
      // Send ingredient name to backend API...
    });

    // Initial rows
    document.querySelectorAll("#ingredients-table tbody tr").forEach((row, index) => {
      initializeIngredientInput(row, index);
    });

    // For dynamically added rows
    // Call initializeIngredientInput(newRow, newIndex) after appending new row

    
  </script>
</body>
</html>
